/**
 * @author      : chedim (chedim@couchbaser)
 * @file        : key_definitions
 * @created     : Friday Jan 28, 2022 20:25:14 EST
 */

#ifndef KEY_DEFINITIONS_C
#define KEY_DEFINITIONS_C
#include <stdlib.h>
#include "key_definitions.h"
#include "keypress_handles.h"
#include "esp_log.h"
#include "usb_hid_keys.h"
#include "keyboard_config.h"

#define TAG "KEYDEF"

uint8_t tapCount = 0;

void KC_NO(uint8_t pressed, uint8_t changed) {

}

uint8_t find_hold(KEY_HANDLER *hold) {
  for (uint8_t i = 0; i < TAP_HOLD_BUFFER; i++) {
    if (holdCodes[i] == hold) {
      return i;
    }
  }
  return -1;
}

void KC_GESC(uint8_t pressed, uint8_t changed) {
  if (!changed) {
    return;
  }
  ESP_LOGI(TAG, "grave escape");
  uint8_t mods = get_mods();
  if (pressed) {
    set_key(mods ? KEY_GRAVE : KEY_ESC);
  } else {
    unset_key(mods ? KEY_GRAVE : KEY_ESC);
  }
}

uint32_t tapCodes[TAP_HOLD_BUFFER] = {0}; 
KEY_HANDLER *holdCodes[TAP_HOLD_BUFFER] = {0};
uint32_t holdStart[TAP_HOLD_BUFFER] = {0};
uint8_t sentHelds[TAP_HOLD_BUFFER] = {0};
uint32_t delayedTaps[TAP_HOLD_BUFFER] = {0};
uint32_t delayedUps[TAP_HOLD_BUFFER] = {0};

uint8_t delayTaps = 0;
uint8_t upCount = 0;

KCI(KC_A, KEY_A);
KCI(KC_B, KEY_B);
KCI(KC_C, KEY_C);
KCI(KC_D, KEY_D);
KCI(KC_E, KEY_E);
KCI(KC_F, KEY_F);
KCI(KC_G, KEY_G);
KCI(KC_H, KEY_H);
KCI(KC_I, KEY_I);
KCI(KC_J, KEY_J);
KCI(KC_K, KEY_K);
KCI(KC_L, KEY_L);
KCI(KC_M, KEY_M);
KCI(KC_N, KEY_N);
KCI(KC_O, KEY_O);
KCI(KC_P, KEY_P);
KCI(KC_Q, KEY_Q);
KCI(KC_R, KEY_R);
KCI(KC_S, KEY_S);
KCI(KC_T, KEY_T);
KCI(KC_U, KEY_U);
KCI(KC_V, KEY_V);
KCI(KC_W, KEY_W);
KCI(KC_X, KEY_X);
KCI(KC_Y, KEY_Y);
KCI(KC_Z, KEY_Z);
KCI(KC_1, KEY_1);
KCI(KC_2, KEY_2);
KCI(KC_3, KEY_3);
KCI(KC_4, KEY_4);
KCI(KC_5, KEY_5);
KCI(KC_6, KEY_6);
KCI(KC_7, KEY_7);
KCI(KC_8, KEY_8);
KCI(KC_9, KEY_9);
KCI(KC_0, KEY_0);
LSFT(KC_LPAREN, KC_9);
RSFT(KC_RPAREN, KC_0);
KCI(KC_ENTER, KEY_ENTER);
//#define KC_ENTER  KCI(KEY_ENTER);
KCI(KC_ESCAPE, KEY_ESC);
KCI(KC_BSPACE, KEY_BACKSPACE);
KCI(KC_TAB, KEY_TAB);
KCI(KC_SPACE, KEY_SPACE);
KCI(KC_MINUS, KEY_MINUS);
KCI(KC_EQUAL, KEY_EQUAL);
KCI(KC_LBRACKET, KEY_LEFTBRACE);
KCI(KC_RBRACKET, KEY_RIGHTBRACE);
KCI(KC_BSLASH, KEY_BACKSLASH);
KCI(KC_NONUS_HASH, KEY_HASHTILDE);
KCI(KC_SCOLON, KEY_SEMICOLON);
KCI(KC_APOSTROPHE,KEY_APOSTROPHE);
KCI(KC_GRAVE, KEY_GRAVE);
KCI(KC_COMMA, KEY_COMMA);
KCI(KC_DOT, KEY_DOT);
KCI(KC_SLASH, KEY_SLASH);
KCI(KC_CAPSLOCK, KEY_CAPSLOCK);
KCI(KC_F1, KEY_F1);
KCI(KC_F2, KEY_F2);
KCI(KC_F3, KEY_F3);
KCI(KC_F4, KEY_F4);
KCI(KC_F5, KEY_F5);
KCI(KC_F6, KEY_F6);
KCI(KC_F7, KEY_F7);
KCI(KC_F8, KEY_F8);
KCI(KC_F9, KEY_F9);
KCI(KC_F10, KEY_F10);
KCI(KC_F11, KEY_F11);
KCI(KC_F12, KEY_F12);
KCI(KC_PSCREEN, KEY_SYSRQ);
KCI(KC_SCROLLLOCK, KEY_SCROLLLOCK);
KCI(KC_PAUSE, KEY_PAUSE);
KCI(KC_INSERT, KEY_INSERT);
KCI(KC_HOME, KEY_HOME);
KCI(KC_PGUP, KEY_PAGEUP);
KCI(KC_DELETE, KEY_DELETE);
KCI(KC_END, KEY_END);
KCI(KC_PGDOWN, KEY_PAGEDOWN);
KCI(KC_RIGHT, KEY_RIGHT);
KCI(KC_LEFT, KEY_LEFT);
KCI(KC_DOWN, KEY_DOWN);
KCI(KC_UP, KEY_UP);
KCI(KC_NUMLOCK, KEY_NUMLOCK);
KCI(KC_KP_SLASH, KEY_KPSLASH);
KCI(KC_KP_ASTERISK, KEY_KPASTERISK);
KCI(KC_KP_MINUS, KEY_KPMINUS);
KCI(KC_KP_PLUS, KEY_KPPLUS);
KCI(KC_KP_ENTER, KEY_KPENTER);
KCI(KC_KP_1, KEY_KP1);
KCI(KC_KP_2, KEY_KP2);
KCI(KC_KP_3, KEY_KP3);
KCI(KC_KP_4, KEY_KP4);
KCI(KC_KP_5, KEY_KP5);
KCI(KC_KP_6, KEY_KP6);
KCI(KC_KP_7, KEY_KP7);
KCI(KC_KP_8, KEY_KP8);
KCI(KC_KP_9, KEY_KP9);
KCI(KC_KP_0, KEY_KP0);
KCI(KC_KP_DOT, KEY_KPDOT);
KCI(KC_NONUS_BSLASH, KEY_102ND);
KCI(KC_APPLICATION, KEY_COMPOSE);
KCI(KC_POWER, KEY_POWER);
KCI(KC_KP_EQUAL, KEY_KPEQUAL);
KCI(KC_F13, KEY_F13);
KCI(KC_F14, KEY_F14);
KCI(KC_F15, KEY_F15);
KCI(KC_F16, KEY_F16);
KCI(KC_F17, KEY_F17);
KCI(KC_F18, KEY_F18);
KCI(KC_F19, KEY_F19);
KCI(KC_F20, KEY_F20);
KCI(KC_F21, KEY_F21);
KCI(KC_F22, KEY_F22);
KCI(KC_F23, KEY_F23);
KCI(KC_F24, KEY_F24);
KCI(KC_EXECUTE, KEY_OPEN);
KCI(KC_HELP, KEY_HELP);
KCI(KC_MENU, KEY_PROPS);
KCI(KC_SELECT, KEY_FRONT);
KCI(KC_STOP, KEY_STOP);
KCI(KC_AGAIN, KEY_AGAIN);
KCI(KC_UNDO, KEY_UNDO);
KCI(KC_CUT, KEY_CUT);
KCI(KC_COPY, KEY_COPY);
KCI(KC_PASTE, KEY_PASTE);
KCI(KC_FIND, KEY_FIND);
KCI(KC__MUTE, KEY_MUTE);
KCI(KC__VOLUP, KEY_VOLUMEUP);
KCI(KC__VOLDOWN, KEY_VOLUMEDOWN);
KCI(KC_LOCKING_CAPS, 0x82);
KCI(KC_LOCKING_NUM, 0x83);
KCI(KC_LOCKING_SCROLL, 0x84);
KCI(KC_KP_COMMA, KEY_KPCOMMA);
KCI(KC_KP_EQUAL_AS400, 0x86);
KCI(KC_INT1, KEY_RO);
KCI(KC_INT2, KEY_KATAKANAHIRAGANA);
KCI(KC_INT3, KEY_YEN);
KCI(KC_INT4, KEY_HENKAN);
KCI(KC_INT5, KEY_MUHENKAN);
KCI(KC_INT6, KEY_KPJPCOMMA);
KCI(KC_INT7, 0x8d);
KCI(KC_INT8, 0x8e);
KCI(KC_INT9, 0x8f);
KCI(KC_LANG1, KEY_HANGEUL);
KCI(KC_LANG2, KEY_HANJA);
KCI(KC_LANG3, KEY_KATAKANA);
KCI(KC_LANG4, KEY_HIRAGANA);
KCI(KC_LANG5, KEY_ZENKAKUHANKAKU);
KCI(KC_LANG6, 0x95);
KCI(KC_LANG7, 0x96);
KCI(KC_LANG8, 0x97);
KCI(KC_LANG9, 0x98);
KCI(KC_ALT_ERASE, 0x99);
KCI(KC_SYSREQ, 0x9a);
KCI(KC_CANCEL, 0x9b);
KCI(KC_CLEAR, 0x9c);
KCI(KC_PRIOR, 0x9d);
KCI(KC_RETURN, 0x9e);
KCI(KC_SEPARATOR, 0x9f);
KCI(KC_OUT, 0xa0);
KCI(KC_OPER, 0xa1);
KCI(KC_CLEAR_AGAIN, 0xa2);
KCI(KC_CRSEL, 0xa3);
KCI(KC_EXSEL, 0xa4);
KCI(KC_KP_00, 0xb0);
KCI(KC_KP_000, 0xb1);
KCI(KC_THOUSANDS_SEPARATOR, 0xb2);
KCI(KC_DECIMAL_SEPARATOR, 0xb3);
KCI(KC_CURRENCY_UNIT, 0xb4);
KCI(KC_CURRENCY_SUB_UNIT, 0xb5);
KCI(KC_KP_LPAREN, KEY_KPLEFTPAREN);
KCI(KC_KP_RPAREN, KEY_KPRIGHTPAREN);
KCI(KC_KP_LCBRACKET, 0xb8);
KCI(KC_KP_RCBRACKET, 0xb9);
KCI(KC_KP_TAB, 0xba);
KCI(KC_KP_BSPACE, 0xbb);
KCI(KC_KP_A, 0xbc);
KCI(KC_KP_B, 0xbd);
KCI(KC_KP_C, 0xbe);
KCI(KC_KP_D, 0xbf);
KCI(KC_KP_E, 0xc0);
KCI(KC_KP_F, 0xc1);
KCI(KC_KP_XOR, 0xc2);
KCI(KC_KP_HAT, 0xc3);
KCI(KC_KP_PERC, 0xc4);
KCI(KC_KP_LT, 0xc5);
KCI(KC_KP_GT, 0xc6);
KCI(KC_KP_AND, 0xc7);
KCI(KC_KP_LAZYAND, 0xc8);
KCI(KC_KP_OR, 0xc9);
KCI(KC_KP_LAZYOR, 0xca);
KCI(KC_KP_COLON, 0xcb);
KCI(KC_KP_HASH, 0xcc);
KCI(KC_KP_SPACE, 0xcd);
KCI(KC_KP_ATMARK, 0xce);
KCI(KC_KP_EXCLAMATION, 0xcf);
KCI(KC_KP_MEM_STORE, 0xd0);
KCI(KC_KP_MEM_RECALL, 0xd1);
KCI(KC_KP_MEM_CLEAR, 0xd2);
KCI(KC_KP_MEM_ADD, 0xd3);
KCI(KC_KP_MEM_SUB, 0xd4);
KCI(KC_KP_MEM_MUL, 0xd5);
KCI(KC_KP_MEM_DIV, 0xd6);
KCI(KC_KP_PLUS_MINUS, 0xd7);
KCI(KC_KP_CLEAR, 0xd8);
KCI(KC_KP_CLEAR_ENTRY, 0xd9);
KCI(KC_KP_BINARY, 0xda);
KCI(KC_KP_OCTAL, 0xdb);
KCI(KC_KP_DECIMAL, 0xdc);
KCI(KC_KP_HEXADECIMAL, 0xdd);

// mofifiers
MOD(KC_LCTRL, HID_MASK_LCTL);
MOD(KC_LSHIFT, HID_MASK_LSFT);
MOD(KC_LALT, HID_MASK_LALT);
MOD(KC_LGUI, HID_MASK_LGUI);
MOD(KC_RCTRL, HID_MASK_RCTL);
MOD(KC_RSHIFT, HID_MASK_RSFT);
MOD(KC_RALT, HID_MASK_RALT);
MOD(KC_RGUI, HID_MASK_RGUI);

KCI(KC_SYSTEM_POWER, 0xa5);
KCI(KC_SYSTEM_SLEEP, 0xa6);
KCI(KC_SYSTEM_WAKE, 0xa7);


LSFT(KC_EXLM, KC_1);
LSFT(KC_DQT, KC_2) 
LSFT(KC_AT, KC_2);
LSFT(KC_HASH, KC_3);
LSFT(KC_DLR, KC_4);
LSFT(KC_PERC, KC_5);
LSFT(KC_CIRC, KC_6);
LSFT(KC_AMPR, KC_7);
LSFT(KC_QUOT, KC_APOSTROPHE);
LSFT(KC_ASTR, KC_8);
LSFT(KC_LPRN, KC_9);
LSFT(KC_RPRN, KC_0);
LSFT(KC_PLUS, KC_EQL);
LSFT(KC_PIPE, KC_YEN);
#define KC_LCBR KC_LBRACKET
#define KC_RCBR KC_RBRACKET
LSFT(KC_UNDS, KC_MINUS);

LSFT(KC_TILD, KC_GRV);

uint8_t isModifier(KEY_HANDLER *key) {
  return key == KC_LSHIFT ||
    key == KC_RSHIFT ||
    key == KC_LCTRL ||
    key == KC_RCTRL ||
    key == KC_LALT ||
    key == KC_RALT ||
    key == KC_LGUI ||
    key == KC_RGUI;
}
#endif
